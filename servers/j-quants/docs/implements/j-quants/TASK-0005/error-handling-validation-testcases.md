# TASK-0005: エラーハンドリング・バリデーション - テストケース定義書

**タスクID**: TASK-0005
**機能名**: エラーハンドリング・バリデーション実装（Error Handling & Validation）
**作成日**: 2025-10-29
**種別**: TDD
**テストフレームワーク**: Vitest 2.1.4
**プログラミング言語**: TypeScript 5.x

---

## 📊 テストケース概要

| 分類 | テストケース数 | 説明 |
|------|---------------|------|
| **正常系** | 10件 | 基本的な動作確認 |
| **異常系** | 8件 | エラーハンドリング確認 |
| **境界値** | 4件 | 境界条件、エッジケース |
| **合計** | 22件 | 要件網羅率100%を目指す |

---

## 🔧 開発言語・フレームワーク

### プログラミング言語: TypeScript 5.x
**信頼性レベル: 🔵 青信号**（プロジェクト技術スタックから確定）

- **言語選択の理由**: プロジェクト標準言語、型安全性、TASK-0002-0004と同じ環境
- **テストに適した機能**:
  - 型チェックによるテストコードの信頼性向上
  - インターフェース定義によるモックの型安全性
  - strict modeによる厳密なエラー検出

### テストフレームワーク: Vitest 2.1.4
**信頼性レベル: 🔵 青信号**（プロジェクト技術スタックから確定）

- **フレームワーク選択の理由**:
  - TASK-0003, TASK-0004で既に採用実績あり
  - TypeScript標準サポート
  - 高速なテスト実行
  - モック機能（vi.fn(), vi.spyOn(), vi.useFakeTimers()）
- **テスト実行環境**: Node.js 20 LTS

---

## 1. error-handler.ts のテストケース（5件）

### TC-NORMAL-001: getErrorMessage() - エラーメッセージ取得（テンプレート変数あり）🔵

**信頼性レベル: 🔵 青信号**（要件定義書のエラーメッセージ定義から抽出）

- **テスト名**: getErrorMessage()でエラーコードとコンテキストから日本語メッセージを取得
  - **何をテストするか**: ErrorCodeとcontextパラメータを渡して適切な日本語エラーメッセージが返却されること
  - **期待される動作**: テンプレート変数（{code}）がcontextの値で置換されること
- **入力値**:
  - errorCode: `ErrorCode.INVALID_CODE`
  - context: `{ code: '9999' }`
  - **入力データの意味**: 不正な銘柄コード"9999"のエラー
- **期待される結果**:
  - 返却メッセージ: `"指定された銘柄コード（9999）は存在しません"`
  - **期待結果の理由**: エラーメッセージ定義に従ったテンプレート置換が正しく動作
- **テストの目的**: エラーメッセージのテンプレート機能確認
  - **確認ポイント**: {code}部分が正しく"9999"に置換されていること

---

### TC-NORMAL-002: getErrorMessage() - エラーメッセージ取得（テンプレート変数なし）🔵

**信頼性レベル: 🔵 青信号**（要件定義書から抽出）

- **テスト名**: getErrorMessage()でcontextなしの場合も正しくメッセージを取得
  - **何をテストするか**: contextパラメータを省略した場合の動作
  - **期待される動作**: テンプレート変数がない固定メッセージが返却される
- **入力値**:
  - errorCode: `ErrorCode.INVALID_DATE`
  - context: undefined
  - **入力データの意味**: 日付形式不正のエラー（コンテキスト不要）
- **期待される結果**:
  - 返却メッセージ: `"日付はYYYY-MM-DD形式で指定してください"`
  - **期待結果の理由**: 固定メッセージが正しく返却される
- **テストの目的**: 固定メッセージの取得確認
  - **確認ポイント**: contextがundefinedでもエラーにならないこと

---

### TC-NORMAL-003: isRetryableError() - リトライ可能エラー（5xx）🔵

**信頼性レベル: 🔵 青信号**（要件定義書のエラー判定ロジックから抽出）

- **テスト名**: isRetryableError()で5xxエラーをリトライ可能と判定
  - **何をテストするか**: HTTPステータス500のエラーがリトライ可能と判定されること
  - **期待される動作**: サーバーエラーはリトライ対象
- **入力値**:
  - error: `{ status: 500, message: 'Internal Server Error' }`
  - **入力データの意味**: サーバー内部エラー
- **期待される結果**:
  - 返却値: `true`
  - **期待結果の理由**: サーバーエラーは一時的なものである可能性が高くリトライすべき
- **テストの目的**: リトライ可能エラーの判定確認
  - **確認ポイント**: 5xxエラーがtrueと判定されること

---

### TC-ERROR-001: isRetryableError() - リトライ不可エラー（400）🔵

**信頼性レベル: 🔵 青信号**（要件定義書のエラー判定ロジックから抽出）

- **テスト名**: isRetryableError()で400エラーをリトライ不可と判定
  - **エラーケースの概要**: クライアントエラー（不正なリクエスト）
  - **エラー処理の重要性**: 不正なリクエストを何度リトライしても成功しない
- **入力値**:
  - error: `{ status: 400, message: 'Bad Request' }`
  - **不正な理由**: クライアント側のリクエスト内容が不正
  - **実際の発生シナリオ**: パラメータバリデーション失敗時
- **期待される結果**:
  - 返却値: `false`
  - **エラーメッセージの内容**: N/A（判定関数のため）
  - **システムの安全性**: 無駄なリトライを防ぎ、エラーを速やかに通知
- **テストの目的**: リトライ不可エラーの判定確認
  - **品質保証の観点**: 無限リトライによるシステム負荷を防止

---

### TC-NORMAL-004: formatErrorResponse() - エラーレスポンス整形🔵

**信頼性レベル: 🔵 青信号**（要件定義書のErrorResponseインターフェースから抽出）

- **テスト名**: formatErrorResponse()でエラーオブジェクトを統一形式に整形
  - **何をテストするか**: 任意のエラーオブジェクトをErrorResponse形式に変換
  - **期待される動作**: code, message, context, timestampを含む統一形式のオブジェクトが返却
- **入力値**:
  - error: `new Error('API connection failed')`
  - **入力データの意味**: 通常のErrorオブジェクト
- **期待される結果**:
  ```typescript
  {
    code: ErrorCode.API_ERROR,
    message: 'API connection failed',
    context: undefined,
    timestamp: '2025-10-29T...'  // ISO 8601形式
  }
  ```
  - **期待結果の理由**: 統一されたエラーレスポンス形式
- **テストの目的**: エラーレスポンスの統一化確認
  - **確認ポイント**: timestampがISO 8601形式で含まれること

---

## 2. validator.ts のテストケース（9件）

### TC-NORMAL-005: validateCode() - 正常な銘柄コード🔵

**信頼性レベル: 🔵 青信号**（要件定義書のバリデーションルールから抽出）

- **テスト名**: validateCode()で4桁数字の銘柄コードが正常と判定
  - **何をテストするか**: 4桁の数字文字列がバリデーションを通過すること
  - **期待される動作**: エラーがスローされずvoidが返却
- **入力値**:
  - code: `'1234'`
  - **入力データの意味**: 標準的な銘柄コード（例: ソフトバンクグループ = 9984）
- **期待される結果**:
  - エラーなし（void）
  - **期待結果の理由**: 4桁数字のパターンに一致
- **テストの目的**: 正常な銘柄コードの受け入れ確認
  - **確認ポイント**: エラーがスローされないこと

---

### TC-ERROR-002: validateCode() - 不正な銘柄コード（3桁）🔵

**信頼性レベル: 🔵 青信号**（要件定義書のバリデーションルールから抽出）

- **テスト名**: validateCode()で3桁の銘柄コードがエラーと判定
  - **エラーケースの概要**: 桁数不足の銘柄コード
  - **エラー処理の重要性**: 不正なコードでAPIリクエストを送らないため
- **入力値**:
  - code: `'123'`
  - **不正な理由**: 銘柄コードは4桁固定
  - **実際の発生シナリオ**: ユーザー入力ミス、データ取得エラー
- **期待される結果**:
  - ValidationError スロー
  - エラーメッセージ: `"銘柄コードは4桁の数字である必要があります"`
  - **システムの安全性**: 不正なリクエストを事前に防止
- **テストの目的**: 桁数バリデーション確認
  - **品質保証の観点**: 入力値検証によるAPI負荷削減

---

### TC-ERROR-003: validateCode() - 不正な銘柄コード（英字含む）🔵

**信頼性レベル: 🔵 青信号**（要件定義書のバリデーションルールから抽出）

- **テスト名**: validateCode()で英字を含む銘柄コードがエラーと判定
  - **エラーケースの概要**: 数字以外の文字が含まれる
  - **エラー処理の重要性**: 米国株式コード（AAPL等）との混同を防ぐ
- **入力値**:
  - code: `'ABCD'`
  - **不正な理由**: 日本の銘柄コードは数字のみ
  - **実際の発生シナリオ**: 米国株コードとの混同
- **期待される結果**:
  - ValidationError スロー
  - エラーメッセージ: `"銘柄コードは4桁の数字である必要があります"`
  - **システムの安全性**: 形式が異なるデータの誤入力を防止
- **テストの目的**: 文字種バリデーション確認
  - **品質保証の観点**: データ形式の厳格な検証

---

### TC-NORMAL-006: validateDate() - 正常な日付🔵

**信頼性レベル: 🔵 青信号**（要件定義書のバリデーションルールから抽出）

- **テスト名**: validateDate()でYYYY-MM-DD形式の日付が正常と判定
  - **何をテストするか**: 標準的なISO 8601日付形式の検証
  - **期待される動作**: エラーがスローされずvoidが返却
- **入力値**:
  - date: `'2025-10-29'`
  - **入力データの意味**: 2025年10月29日（妥当な日付）
- **期待される結果**:
  - エラーなし（void）
  - **期待結果の理由**: YYYY-MM-DD形式かつ実在する日付
- **テストの目的**: 正常な日付の受け入れ確認
  - **確認ポイント**: 形式と実在性の両方が確認されること

---

### TC-ERROR-004: validateDate() - 不正な日付形式🔵

**信頼性レベル: 🔵 青信号**（要件定義書のバリデーションルールから抽出）

- **テスト名**: validateDate()でDD/MM/YYYY形式の日付がエラーと判定
  - **エラーケースの概要**: 日付形式が異なる
  - **エラー処理の重要性**: API仕様（YYYY-MM-DD）との整合性確保
- **入力値**:
  - date: `'29/10/2025'`
  - **不正な理由**: スラッシュ区切りの日付形式
  - **実際の発生シナリオ**: 異なる地域フォーマットの混入
- **期待される結果**:
  - ValidationError スロー
  - エラーメッセージ: `"日付はYYYY-MM-DD形式で指定してください"`
  - **システムの安全性**: API仕様違反を事前に検出
- **テストの目的**: 日付形式バリデーション確認
  - **品質保証の観点**: 統一された形式でのデータ処理

---

### TC-ERROR-005: validateDate() - 実在しない日付🔵

**信頼性レベル: 🔵 青信号**（要件定義書のバリデーションルールから抽出）

- **テスト名**: validateDate()で実在しない日付（2025-13-40）がエラーと判定
  - **エラーケースの概要**: 形式は正しいが実在しない日付
  - **エラー処理の重要性**: データの妥当性確認
- **入力値**:
  - date: `'2025-13-40'`
  - **不正な理由**: 13月40日は存在しない
  - **実際の発生シナリオ**: 入力ミス、データ破損
- **期待される結果**:
  - ValidationError スロー
  - エラーメッセージ: `"実在しない日付です"`
  - **システムの安全性**: 無効なデータでのAPI呼び出しを防止
- **テストの目的**: 日付の実在性確認
  - **品質保証の観点**: Date.parse()による実在性検証

---

### TC-NORMAL-007: validateDateRange() - 正常な日付範囲🔵

**信頼性レベル: 🔵 青信号**（要件定義書のバリデーションルールから抽出）

- **テスト名**: validateDateRange()でfrom <= toの日付範囲が正常と判定
  - **何をテストするか**: 開始日が終了日以前であることの確認
  - **期待される動作**: エラーがスローされずvoidが返却
- **入力値**:
  - from: `'2025-01-01'`
  - to: `'2025-12-31'`
  - **入力データの意味**: 1年間のデータ取得範囲
- **期待される結果**:
  - エラーなし（void）
  - **期待結果の理由**: from <= to の関係が成立
- **テストの目的**: 正常な日付範囲の受け入れ確認
  - **確認ポイント**: 両方の日付が個別に検証され、範囲も正しいこと

---

### TC-ERROR-006: validateDateRange() - 逆順の日付範囲🔵

**信頼性レベル: 🔵 青信号**（要件定義書のバリデーションルールから抽出）

- **テスト名**: validateDateRange()でfrom > toの日付範囲がエラーと判定
  - **エラーケースの概要**: 開始日が終了日より後
  - **エラー処理の重要性**: 論理的に無効な範囲の検出
- **入力値**:
  - from: `'2025-12-31'`
  - to: `'2025-01-01'`
  - **不正な理由**: 終了日が開始日より前
  - **実際の発生シナリオ**: パラメータ順序の誤り
- **期待される結果**:
  - ValidationError スロー
  - エラーメッセージ: `"日付範囲が不正です（from > to）"`
  - **システムの安全性**: 論理的に無効な範囲でのAPI呼び出しを防止
- **テストの目的**: 日付範囲の順序確認
  - **品質保証の観点**: ビジネスロジックの妥当性検証

---

### TC-BOUNDARY-001: validateRequiredParam() - null値🔵

**信頼性レベル: 🔵 青信号**（要件定義書のバリデーションルールから抽出）

- **テスト名**: validateRequiredParam()でnull値が必須パラメータ不足と判定
  - **境界値の意味**: null/undefined/空文字列の境界
  - **境界値での動作保証**: falsy値の厳密な判定
- **入力値**:
  - value: `null`
  - paramName: `'code'`
  - **境界値選択の根拠**: JavaScriptのfalsyな値の代表例
  - **実際の使用場面**: オプショナルパラメータの誤った使用
- **期待される結果**:
  - ValidationError スロー
  - エラーメッセージ: `"必須パラメータ code が指定されていません"`
  - **境界での正確性**: null, undefined, '' すべてがエラーと判定されること
  - **一貫した動作**: どのfalsyな値でも同じエラーメッセージ
- **テストの目的**: 必須パラメータの厳密な確認
  - **堅牢性の確認**: null安全性の保証

---

### TC-NORMAL-008: validateEnum() - 列挙型の正常値🟡

**信頼性レベル: 🟡 黄信号**（要件定義書から推測、実装詳細は不明）

- **テスト名**: validateEnum()でMarket列挙型の正常値が受け入れられる
  - **何をテストするか**: TypeScript列挙型の値検証
  - **期待される動作**: 列挙型に含まれる値がバリデーションを通過
- **入力値**:
  - value: `'Prime'`
  - enumObj: `Market`（src/types/index.ts の Market 列挙型）
  - paramName: `'market'`
  - **入力データの意味**: 東証プライム市場
- **期待される結果**:
  - エラーなし（void）
  - **期待結果の理由**: 'Prime' は Market列挙型に含まれる
- **テストの目的**: 列挙型バリデーション確認
  - **確認ポイント**: 大文字小文字が正確に一致すること

---

## 3. logger.ts のテストケース（4件）

### TC-NORMAL-009: error() - エラーログ記録🔵

**信頼性レベル: 🔵 青信号**（要件定義書のログフォーマットから抽出）

- **テスト名**: error()でエラーメッセージがlogs/error.logに記録される
  - **何をテストするか**: ログファイルへの書き込み動作
  - **期待される動作**: タイムスタンプ、ログレベル、メッセージを含むログエントリが作成
- **入力値**:
  - message: `'Test error message'`
  - context: `{ code: '1234', operation: 'getStockPrice' }`
  - **入力データの意味**: 銘柄コード1234の株価取得時のエラー
- **期待される結果**:
  - `logs/error.log` ファイルが作成される
  - ログ内容:
    ```
    [2025-10-29T15:22:30.123Z] ERROR: Test error message
    Context: {"code":"1234","operation":"getStockPrice"}
    ```
  - **期待結果の理由**: タイムスタンプ、ログレベル、メッセージ、コンテキストの完全な記録
- **テストの目的**: エラーログの記録確認
  - **確認ポイント**: fs.appendFileSync()が呼ばれること、ファイルが存在すること

---

### TC-NORMAL-010: debug() - デバッグログ（development環境）🔵

**信頼性レベル: 🔵 青信号**（要件定義書のdebug()仕様から抽出）

- **テスト名**: debug()でNODE_ENV=developmentの場合にコンソール出力される
  - **何をテストするか**: 環境変数による条件付きログ出力
  - **期待される動作**: developmentモードでのみdebugログが出力
- **入力値**:
  - message: `'Debug info'`
  - context: `{ variable: 'value' }`
  - 環境変数: `process.env.NODE_ENV = 'development'`
  - **入力データの意味**: 開発環境でのデバッグ情報
- **期待される結果**:
  - console.log()が呼ばれる
  - 出力内容: `"[DEBUG] Debug info"`
  - **期待結果の理由**: 開発環境でのみデバッグ情報を出力
- **テストの目的**: 条件付きログ出力確認
  - **確認ポイント**: NODE_ENVの値によってログの有無が切り替わること

---

### TC-BOUNDARY-002: error() - 空のコンテキスト🔵

**信頼性レベル: 🔵 青信号**（要件定義書から推測）

- **テスト名**: error()でcontextがundefinedの場合もログ記録される
  - **境界値の意味**: contextパラメータの省略可能性
  - **境界値での動作保証**: オプショナルパラメータの扱い
- **入力値**:
  - message: `'Error without context'`
  - context: `undefined`
  - **境界値選択の根拠**: contextはオプショナル
  - **実際の使用場面**: コンテキスト情報が不要なシンプルなエラー
- **期待される結果**:
  - `logs/error.log` に記録される
  - ログ内容:
    ```
    [2025-10-29T15:22:30.123Z] ERROR: Error without context
    ```
  - **境界での正確性**: contextなしでもエラーが発生しないこと
  - **一貫した動作**: メッセージ部分は同じフォーマット
- **テストの目的**: オプショナルパラメータの動作確認
  - **堅牢性の確認**: context省略時もクラッシュしないこと

---

### TC-BOUNDARY-003: error() - ログディレクトリが存在しない🟡

**信頼性レベル: 🟡 黄信号**（要件定義書から推測、実装詳細不明）

- **テスト名**: error()でlogs/ディレクトリが存在しない場合に自動作成される
  - **境界値の意味**: 初回実行時の状態
  - **境界値での動作保証**: ファイルシステムの初期化
- **入力値**:
  - message: `'First error'`
  - 前提条件: `logs/` ディレクトリが存在しない
  - **境界値選択の根拠**: アプリケーション初回起動時
  - **実際の使用場面**: 初回デプロイ直後
- **期待される結果**:
  - `logs/` ディレクトリが自動作成される
  - `logs/error.log` が作成される
  - **境界での正確性**: fs.mkdirSync()が呼ばれること
  - **一貫した動作**: ディレクトリ作成後も通常通りログ記録
- **テストの目的**: ファイルシステム初期化確認
  - **堅牢性の確認**: 事前準備なしでも動作すること

---

## 4. retry.ts のテストケース（4件）

### TC-NORMAL-011: sleep() - 指定時間待機🔵

**信頼性レベル: 🔵 青信号**（要件定義書のsleep()仕様から抽出）

- **テスト名**: sleep()で指定ミリ秒待機してPromiseがresolveされる
  - **何をテストするか**: Promise-based遅延関数の動作
  - **期待される動作**: 指定時間経過後にresolve
- **入力値**:
  - ms: `1000`
  - **入力データの意味**: 1秒待機
- **期待される結果**:
  - 1秒後にPromiseがresolve
  - 返却値: `void`
  - **期待結果の理由**: setTimeoutによる遅延実装
- **テストの目的**: 遅延関数の動作確認
  - **確認ポイント**: vi.useFakeTimers()で時間を進めてテスト

---

### TC-NORMAL-012: calculateBackoffDelay() - Exponential backoff計算🔵

**信頼性レベル: 🔵 青信号**（要件定義書の計算式から抽出）

- **テスト名**: calculateBackoffDelay()でExponential backoffの遅延時間が計算される
  - **何をテストするか**: 指数バックオフアルゴリズムの計算
  - **期待される動作**: attempt回数に応じた遅延時間の計算
- **入力値**:
  - attempt: `0, 1, 2`
  - baseDelay: `1000`
  - **入力データの意味**: 1回目、2回目、3回目のリトライ
- **期待される結果**:
  - attempt 0 → `1000ms`
  - attempt 1 → `2000ms`
  - attempt 2 → `4000ms`
  - **期待結果の理由**: `baseDelay * (2 ^ attempt)` の計算式
- **テストの目的**: Exponential backoffアルゴリズム確認
  - **確認ポイント**: 各attemptで正しい遅延時間が計算されること

---

### TC-NORMAL-013: retryableRequest() - 成功パターン（1回目で成功）🔵

**信頼性レベル: 🔵 青信号**（要件定義書のretryableRequest()仕様から抽出）

- **テスト名**: retryableRequest()で1回目の実行が成功した場合にリトライなし
  - **何をテストするか**: 成功時はリトライしないこと
  - **期待される動作**: 即座に結果を返却
- **入力値**:
  - fn: `async () => 'success result'`（常に成功する関数）
  - maxRetries: `3`
  - **入力データの意味**: 正常に動作するAPI呼び出し
- **期待される結果**:
  - 返却値: `'success result'`
  - fnの実行回数: 1回のみ
  - **期待結果の理由**: 成功時は追加の試行不要
- **テストの目的**: 成功時の即時返却確認
  - **確認ポイント**: fnが1回だけ呼ばれること

---

### TC-ERROR-007: retryableRequest() - 最大リトライ超過🔵

**信頼性レベル: 🔵 青信号**（要件定義書のretryableRequest()仕様から抽出）

- **テスト名**: retryableRequest()で最大リトライ回数に達したらエラーをスロー
  - **エラーケースの概要**: すべてのリトライが失敗
  - **エラー処理の重要性**: 無限リトライを防ぐ
- **入力値**:
  - fn: `async () => { throw new Error('Persistent error'); }`（常に失敗）
  - maxRetries: `3`
  - **不正な理由**: API側の恒久的な障害
  - **実際の発生シナリオ**: サービス停止、ネットワーク断絶
- **期待される結果**:
  - Error スロー: `'Persistent error'`
  - fnの実行回数: 3回
  - **エラーメッセージの内容**: 最後のエラーがスローされる
  - **システムの安全性**: 無限リトライによるリソース枯渇を防止
- **テストの目的**: リトライ上限の確認
  - **品質保証の観点**: フェイルファスト原則

---

## 🎯 テストケース実装時の日本語コメント指針

### テストケース開始時のコメント

```typescript
/**
 * TC-NORMAL-001: getErrorMessage() - エラーメッセージ取得 🔵
 *
 * 【テスト目的】: ErrorCodeとcontextからテンプレート置換された日本語メッセージを取得できること
 * 【テスト内容】: INVALID_CODEエラーで{code}テンプレート変数を"9999"に置換
 * 【期待される動作】: "指定された銘柄コード（9999）は存在しません" というメッセージが返却される
 * 🔵 信頼性レベル: 青信号（要件定義書のエラーメッセージ定義から確定）
 */
```

### Given（準備フェーズ）のコメント

```typescript
// Given（前提条件）: エラーコードとコンテキストを準備
// 【テストデータ準備】: 不正な銘柄コード"9999"のエラーを想定
const errorCode = ErrorCode.INVALID_CODE;
const context = { code: '9999' };
```

### When（実行フェーズ）のコメント

```typescript
// When（実行）: getErrorMessage()を呼び出してメッセージ取得
// 【実際の処理実行】: エラーコードとコンテキストを渡してメッセージ生成
const message = getErrorMessage(errorCode, context);
```

### Then（検証フェーズ）のコメント

```typescript
// Then（検証）: テンプレート変数が正しく置換されたメッセージが返却される
// 【結果検証】: {code}が"9999"に置換されていることを確認
expect(message).toBe('指定された銘柄コード（9999）は存在しません');
// 【確認内容】: エラーメッセージが日本語で、テンプレート置換が正確に動作
```

---

## 📊 要件カバレッジ

| 要件ID | 要件内容 | テストケース | カバレッジ |
|--------|---------|------------|-----------|
| **REQ-601** | リトライロジック | TC-NORMAL-013, TC-ERROR-007 | ✅ 100% |
| **REQ-602** | エラーハンドリング | TC-NORMAL-001～004, TC-ERROR-001 | ✅ 100% |
| **REQ-603** | タイムアウト制御 | TC-NORMAL-011 | ✅ 100% |
| **REQ-701** | MCPツール共通基盤 | 全テストケース | ✅ 100% |
| **NFR-301** | 日本語メッセージ | TC-NORMAL-001, TC-NORMAL-002 | ✅ 100% |

**要件カバレッジ**: ✅ **5/5要件（100%）**

---

## 🧪 テストファイル構成

### tests/utils/error-handler.test.ts
- TC-NORMAL-001: getErrorMessage() - テンプレート変数あり
- TC-NORMAL-002: getErrorMessage() - テンプレート変数なし
- TC-NORMAL-003: isRetryableError() - 5xxエラー
- TC-NORMAL-004: formatErrorResponse() - エラーレスポンス整形
- TC-ERROR-001: isRetryableError() - 400エラー

### tests/utils/validator.test.ts
- TC-NORMAL-005: validateCode() - 正常
- TC-NORMAL-006: validateDate() - 正常
- TC-NORMAL-007: validateDateRange() - 正常
- TC-NORMAL-008: validateEnum() - 正常
- TC-ERROR-002: validateCode() - 3桁
- TC-ERROR-003: validateCode() - 英字
- TC-ERROR-004: validateDate() - 不正形式
- TC-ERROR-005: validateDate() - 実在しない日付
- TC-ERROR-006: validateDateRange() - 逆順
- TC-BOUNDARY-001: validateRequiredParam() - null値

### tests/utils/logger.test.ts
- TC-NORMAL-009: error() - エラーログ記録
- TC-NORMAL-010: debug() - デバッグログ（development）
- TC-BOUNDARY-002: error() - 空のコンテキスト
- TC-BOUNDARY-003: error() - ログディレクトリ不在

### tests/utils/retry.test.ts
- TC-NORMAL-011: sleep() - 指定時間待機
- TC-NORMAL-012: calculateBackoffDelay() - Exponential backoff
- TC-NORMAL-013: retryableRequest() - 成功パターン
- TC-ERROR-007: retryableRequest() - 最大リトライ超過

---

**作成者**: Claude (Sonnet 4.5)
**作成日**: 2025-10-29
**参照要件定義**: error-handling-validation-requirements.md
**次フェーズ**: Red Phase (`/tsumiki:tdd-red`)
