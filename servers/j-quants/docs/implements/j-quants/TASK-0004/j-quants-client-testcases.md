# TASK-0004: J-Quants APIクライアント基礎 - テストケース仕様書

**タスクID**: TASK-0004
**機能名**: JQuantsClient（J-Quants APIクライアント基礎）
**作成日**: 2025-10-29
**テストフレームワーク**: Vitest 2.1.4
**言語**: TypeScript 5.6.3
**テストファイル**: `tests/api/j-quants-client.test.ts`

---

## 開発言語・フレームワーク

### 🔵 プログラミング言語: TypeScript 5.6.3
- **言語選択の理由**:
  - プロジェクト全体がTypeScriptで実装されている（package.json確認済み）
  - 型安全性による品質保証
  - IDEの強力な補完機能でテスト作成が効率的
- **テストに適した機能**:
  - ジェネリック型によるモック作成の柔軟性
  - インターフェースによるテスト対象の明確な定義
  - strict modeによる厳密な型チェック

### 🔵 テストフレームワーク: Vitest 2.1.4
- **フレームワーク選択の理由**:
  - 既にプロジェクトで採用されている（vitest.config.ts確認済み）
  - TASK-0003（TokenManager）で実績あり
  - Vite/Vitestエコシステムの高速実行
  - Jest互換のAPIで学習コストが低い
- **テスト実行環境**:
  - Node.js 20.0.0以上（package.json engines指定）
  - カバレッジプロバイダー: v8
  - グローバルモード有効（globals: true）

---

## テストケース概要

| 分類 | テストケース数 | 説明 |
|------|---------------|------|
| **正常系** | 9件 | 基本的な動作確認 |
| **異常系** | 7件 | エラーハンドリング確認 |
| **境界値** | 6件 | リトライロジック、タイムアウト、境界条件 |
| **合計** | 22件 | 要件網羅率100%を目指す |

---

## 1. 正常系テストケース（9件）

### TC-NORMAL-001: 基本HTTPリクエスト（GET /listed/info）🔵

- **テスト名**: 銘柄一覧取得の基本HTTPリクエスト
  - **何をテストするか**: JQuantsClient.getListedInfo()が正常にHTTPリクエストを送信し、レスポンスを取得できること
  - **期待される動作**: fetch APIでGET /listed/infoを呼び出し、Company[]型のレスポンスを返却

- **入力値**:
  - TokenManager: モックインスタンス（getIdToken()が'test_token_12345'を返却）
  - APIレスポンス: `[{ code: '7203', name: 'トヨタ自動車', market: 'Prime', sector: '0050' }]`
  - **入力データの意味**: 正常なAPIレスポンスを模擬し、基本的なHTTP通信が機能することを確認

- **期待される結果**:
  - `getListedInfo()`の返却値が`Company[]`型である
  - 返却値の1番目の要素が`{ code: '7203', name: 'トヨタ自動車', market: 'Prime', sector: '0050' }`である
  - fetchが1回呼ばれる
  - **期待結果の理由**: HTTP通信の基本的な動作が正常であることを保証

- **テストの目的**:
  - HTTP通信の基本動作確認
  - レスポンスのマッピング確認
  - **確認ポイント**: fetchが正しいURLで呼ばれること、レスポンスが正しく解析されること

- **要件根拠**: REQ-001（認証）, REQ-002（IDトークン取得）

- 🔵 **信頼性レベル**: 青信号（要件定義書、既存実装パターンに基づく）

---

### TC-NORMAL-002: 認証ヘッダー付与（Bearer Token）🔵

- **テスト名**: Authorization ヘッダーに Bearer Token が正しく付与されること
  - **何をテストするか**: すべてのAPIリクエストにAuthorization: Bearer {idToken}ヘッダーが付与されること
  - **期待される動作**: TokenManager.getIdToken()で取得したトークンがHTTPヘッダーに含まれる

- **入力値**:
  - TokenManager.getIdToken(): 'test_id_token_xyz789'を返却
  - **入力データの意味**: 認証トークンが正しくヘッダーに含まれることを確認

- **期待される結果**:
  - fetchの呼び出し時、headersに`{ 'Authorization': 'Bearer test_id_token_xyz789' }`が含まれる
  - TokenManager.getIdToken()が1回呼ばれる
  - **期待結果の理由**: J-Quants APIは認証が必須のため、正しいヘッダー付与を保証

- **テストの目的**:
  - 認証ヘッダーの付与確認
  - TokenManagerとの連携確認
  - **確認ポイント**: Bearerトークン形式が正しいこと

- **要件根拠**: REQ-001（認証）, NFR-101（セキュリティ）

- 🔵 **信頼性レベル**: 青信号（TokenManagerの実装パターンから確実）

---

### TC-NORMAL-003: 株価データ取得（クエリパラメータ付き）🔵

- **テスト名**: getDailyQuotes()でクエリパラメータが正しく構築されること
  - **何をテストするか**: code, from, toパラメータがクエリストリングに正しく変換されること
  - **期待される動作**: GET /prices/daily_quotes?code=7203&from=2025-01-01&to=2025-12-31 が呼ばれる

- **入力値**:
  - code: '7203'（トヨタ自動車）
  - from: '2025-01-01'
  - to: '2025-12-31'
  - **入力データの意味**: 1年間の株価データ取得を想定

- **期待される結果**:
  - fetchのURLが`https://api.jquants.com/v1/prices/daily_quotes?code=7203&from=2025-01-01&to=2025-12-31`である
  - 返却値が`StockPrice[]`型である
  - **期待結果の理由**: クエリパラメータの構築が正確であることを保証

- **テストの目的**:
  - クエリパラメータの構築確認
  - URL エンコーディング確認
  - **確認ポイント**: パラメータが正しい順序と形式でURLに含まれること

- **要件根拠**: REQ-201（株価データ取得）

- 🔵 **信頼性レベル**: 青信号（要件定義書の仕様に基づく）

---

### TC-NORMAL-004: 財務諸表取得（typeパラメータ付き）🔵

- **テスト名**: getStatements()でtypeパラメータが正しく送信されること
  - **何をテストするか**: StatementType（Consolidated/NonConsolidated）が正しくAPIに渡されること
  - **期待される動作**: GET /fins/statements?code=7203&type=Consolidated が呼ばれる

- **入力値**:
  - code: '7203'
  - type: 'Consolidated'（連結財務諸表）
  - **入力データの意味**: 連結財務諸表の取得を想定

- **期待される結果**:
  - fetchのURLに`type=Consolidated`が含まれる
  - 返却値が`FinancialStatements`型である
  - **期待結果の理由**: 列挙型パラメータの送信が正確であることを保証

- **テストの目的**:
  - オプショナルパラメータの処理確認
  - 列挙型の送信確認
  - **確認ポイント**: typeが省略された場合の動作も確認

- **要件根拠**: REQ-301（財務諸表取得）

- 🔵 **信頼性レベル**: 青信号（型定義から確実）

---

### TC-NORMAL-005: 企業情報取得🔵

- **テスト名**: getCompanyInfo()が正しいエンドポイントを呼び出すこと
  - **何をテストするか**: パスパラメータ形式（/listed/info/{code}）のエンドポイント呼び出し
  - **期待される動作**: GET /listed/info/7203 が呼ばれる

- **入力値**:
  - code: '7203'
  - **入力データの意味**: 特定銘柄の企業情報取得を想定

- **期待される結果**:
  - fetchのURLが`https://api.jquants.com/v1/listed/info/7203`である
  - 返却値が`CompanyInfo`型である
  - **期待結果の理由**: パスパラメータの構築が正確であることを保証

- **テストの目的**:
  - パスパラメータの構築確認
  - RESTful APIパターンの確認
  - **確認ポイント**: codeが正しくURLパスに埋め込まれること

- **要件根拠**: REQ-401（企業情報取得）

- 🔵 **信頼性レベル**: 青信号（要件定義書の仕様に基づく）

---

### TC-NORMAL-006: getListedInfo()メソッドの正常動作🔵

- **テスト名**: getListedInfo()がCompany[]を返却すること
  - **何をテストするか**: publicメソッドとしてのgetListedInfo()の完全な動作
  - **期待される動作**: TokenManager連携、HTTP通信、レスポンスマッピングまで一連の処理が成功

- **入力値**:
  - なし（引数なし）
  - **入力データの意味**: 全銘柄一覧取得を想定

- **期待される結果**:
  - 返却値が`Company[]`型である
  - 配列の各要素がCompanyインターフェースを満たす
  - **期待結果の理由**: publicメソッドの契約を保証

- **テストの目的**:
  - publicメソッドの動作保証
  - 型安全性の確認
  - **確認ポイント**: 返却値の型が正確であること

- **要件根拠**: REQ-101（銘柄一覧取得）

- 🔵 **信頼性レベル**: 青信号（既存実装パターンから確実）

---

### TC-NORMAL-007: getDailyQuotes()メソッドの正常動作🔵

- **テスト名**: getDailyQuotes()がStockPrice[]を返却すること
  - **何をテストするか**: publicメソッドとしてのgetDailyQuotes()の完全な動作
  - **期待される動作**: 必須パラメータ（code）とオプショナルパラメータ（from, to）の処理が正常

- **入力値**:
  - code: '7203'
  - from: undefined（省略）
  - to: undefined（省略）
  - **入力データの意味**: 日付範囲指定なしの株価取得を想定

- **期待される結果**:
  - 返却値が`StockPrice[]`型である
  - from/toが省略された場合、クエリパラメータに含まれない
  - **期待結果の理由**: オプショナルパラメータの適切な処理を保証

- **テストの目的**:
  - publicメソッドの動作保証
  - オプショナルパラメータの処理確認
  - **確認ポイント**: パラメータ省略時の動作が正確であること

- **要件根拠**: REQ-201（株価データ取得）

- 🔵 **信頼性レベル**: 青信号（型定義から確実）

---

### TC-NORMAL-008: getStatements()メソッドの正常動作🔵

- **テスト名**: getStatements()がFinancialStatementsを返却すること
  - **何をテストするか**: publicメソッドとしてのgetStatements()の完全な動作
  - **期待される動作**: 財務諸表データの取得が正常に完了

- **入力値**:
  - code: '7203'
  - type: 'Consolidated'
  - **入力データの意味**: 連結財務諸表取得を想定

- **期待される結果**:
  - 返却値が`FinancialStatements`型である
  - balance_sheet, profit_loss, cash_flowの各プロパティが含まれる
  - **期待結果の理由**: 財務諸表の完全な構造を保証

- **テストの目的**:
  - publicメソッドの動作保証
  - 複雑なオブジェクト構造の確認
  - **確認ポイント**: ネストされたオブジェクトが正しくマッピングされること

- **要件根拠**: REQ-301（財務諸表取得）

- 🔵 **信頼性レベル**: 青信号（型定義から確実）

---

### TC-NORMAL-009: getCompanyInfo()メソッドの正常動作🔵

- **テスト名**: getCompanyInfo()がCompanyInfoを返却すること
  - **何をテストするか**: publicメソッドとしてのgetCompanyInfo()の完全な動作
  - **期待される動作**: 企業情報と最新株価の組み合わせデータが取得される

- **入力値**:
  - code: '7203'
  - **入力データの意味**: 特定企業の詳細情報取得を想定

- **期待される結果**:
  - 返却値が`CompanyInfo`型である
  - code, name, market, sector, latest_priceの各プロパティが含まれる
  - **期待結果の理由**: 企業情報の完全性を保証

- **テストの目的**:
  - publicメソッドの動作保証
  - 複合データの取得確認
  - **確認ポイント**: すべての必須フィールドが含まれること

- **要件根拠**: REQ-401（企業情報取得）

- 🔵 **信頼性レベル**: 青信号（型定義から確実）

---

## 2. 異常系テストケース（7件）

### TC-ERROR-001: バリデーションエラー（400、リトライなし）🔵

- **テスト名**: 400エラー時はリトライせず即座にエラーをスローすること
  - **エラーケースの概要**: 無効な銘柄コードなどのクライアント側エラー
  - **エラー処理の重要性**: 不正な入力値に対してリトライしても無駄なため、即座にエラー通知

- **入力値**:
  - code: 'INVALID'（無効な銘柄コード）
  - APIレスポンス: 400 Bad Request
  - **不正な理由**: 銘柄コードは4桁数字である必要がある
  - **実際の発生シナリオ**: ユーザーが誤った銘柄コードを入力した場合

- **期待される結果**:
  - Errorがスローされる
  - fetchが1回のみ呼ばれる（リトライなし）
  - エラーメッセージが「無効な銘柄コードです。4桁の数字を指定してください。」である
  - **エラーメッセージの内容**: ユーザーが問題を理解し修正できる内容
  - **システムの安全性**: 無駄なリトライを避け、APIサーバーへの負荷を軽減

- **テストの目的**:
  - リトライ対象外エラーの判定確認
  - 適切なエラーメッセージの確認
  - **品質保証の観点**: ユーザーエクスペリエンスの向上（適切なエラー通知）

- **要件根拠**: REQ-601（リトライロジック）, NFR-301（日本語エラーメッセージ）

- 🔵 **信頼性レベル**: 青信号（要件定義書の仕様に基づく）

---

### TC-ERROR-002: 認証エラー（401、トークン再取得）🔵

- **テスト名**: 401エラー時はTokenManager.getIdToken()で新しいトークンを取得してリトライすること
  - **エラーケースの概要**: IDトークンが無効または期限切れ
  - **エラー処理の重要性**: トークンの自動更新により、ユーザーの操作なしで継続動作

- **入力値**:
  - 1回目のIDトークン: 'expired_token_old123'（期限切れ）
  - 2回目のIDトークン: 'new_token_fresh456'（新規取得）
  - APIレスポンス: 1回目は401、2回目は200 OK
  - **不正な理由**: トークンの有効期限が切れている
  - **実際の発生シナリオ**: APIリクエスト中にトークンが期限切れになった場合

- **期待される結果**:
  - TokenManager.getIdToken()が2回呼ばれる
  - fetchが2回呼ばれる（1回目401、2回目200）
  - 最終的に正常なレスポンスが返却される
  - **エラーメッセージの内容**: エラーがスローされない（自動リカバリ成功）
  - **システムの安全性**: ユーザーに意識させずにトークン更新

- **テストの目的**:
  - 401エラー時の特別処理確認
  - TokenManagerとの連携確認
  - **品質保証の観点**: システムの自動回復能力の保証

- **要件根拠**: REQ-004（認証失敗時の再取得）, REQ-601（リトライロジック）

- 🔵 **信頼性レベル**: 青信号（TokenManagerの実装パターンから確実）

---

### TC-ERROR-003: レート制限エラー（429、リトライ対象）🔵

- **テスト名**: 429エラー時は自動的にリトライすること
  - **エラーケースの概要**: APIレート制限に到達
  - **エラー処理の重要性**: 一時的な制限に対して自動リトライで継続動作

- **入力値**:
  - APIレスポンス: 1回目は429、2回目は200 OK
  - **不正な理由**: APIの呼び出し頻度が制限を超えた
  - **実際の発生シナリオ**: 大量のデータ取得処理中にレート制限に到達

- **期待される結果**:
  - fetchが2回呼ばれる（1回目429、2回目200）
  - 1秒待機後にリトライされる
  - 最終的に正常なレスポンスが返却される
  - **エラーメッセージの内容**: エラーがスローされない（リトライ成功）
  - **システムの安全性**: APIサーバーへの負荷を考慮したリトライ間隔

- **テストの目的**:
  - レート制限への対応確認
  - リトライロジックの動作確認
  - **品質保証の観点**: システムの耐障害性の保証

- **要件根拠**: REQ-601（リトライロジック）

- 🔵 **信頼性レベル**: 青信号（要件定義書の仕様に基づく）

---

### TC-ERROR-004: サーバーエラー（500、リトライ対象）🔵

- **テスト名**: 500エラー時は自動的にリトライすること
  - **エラーケースの概要**: J-Quants APIサーバーの一時的なエラー
  - **エラー処理の重要性**: サーバー側の一時的な問題に対して自動リトライで継続動作

- **入力値**:
  - APIレスポンス: 1回目は500、2回目は500、3回目は200 OK
  - **不正な理由**: サーバー内部エラー
  - **実際の発生シナリオ**: J-QuantsAPIサーバーの一時的な障害

- **期待される結果**:
  - fetchが3回呼ばれる（1回目500、2回目500、3回目200）
  - 1秒待機、2秒待機後にリトライされる（Exponential backoff）
  - 最終的に正常なレスポンスが返却される
  - **エラーメッセージの内容**: エラーがスローされない（リトライ成功）
  - **システムの安全性**: サーバーへの負荷を考慮した段階的待機時間

- **テストの目的**:
  - サーバーエラーへの対応確認
  - Exponential backoffの動作確認
  - **品質保証の観点**: システムの回復力の保証

- **要件根拠**: REQ-601（リトライロジック）

- 🔵 **信頼性レベル**: 青信号（要件定義書の仕様に基づく）

---

### TC-ERROR-005: ネットワークエラー（TypeError、リトライ対象）🔵

- **テスト名**: ネットワークエラー時は自動的にリトライすること
  - **エラーケースの概要**: インターネット接続の一時的な切断
  - **エラー処理の重要性**: ネットワークの一時的な問題に対して自動リトライで継続動作

- **入力値**:
  - fetch動作: 1回目はTypeErrorをスロー、2回目は200 OK
  - **不正な理由**: ネットワーク接続が一時的に切断された
  - **実際の発生シナリオ**: Wi-Fi接続の一時的な切断、プロキシの問題

- **期待される結果**:
  - fetchが2回呼ばれる（1回目TypeError、2回目200）
  - 1秒待機後にリトライされる
  - 最終的に正常なレスポンスが返却される
  - **エラーメッセージの内容**: エラーがスローされない（リトライ成功）
  - **システムの安全性**: ネットワーク回復を待つ適切な待機時間

- **テストの目的**:
  - ネットワークエラーへの対応確認
  - TypeErrorの判定確認
  - **品質保証の観点**: システムの耐障害性の保証

- **要件根拠**: REQ-601（リトライロジック）, EDGE-201（ネットワークエラー）

- 🔵 **信頼性レベル**: 青信号（要件定義書とTokenManagerの実装パターンから確実）

---

### TC-ERROR-006: タイムアウトエラー（5秒超過、リトライ対象）🔵

- **テスト名**: 5秒以内に応答がない場合はAbortControllerでキャンセルしリトライすること
  - **エラーケースの概要**: APIサーバーの応答遅延
  - **エラー処理の重要性**: 無限待機を避け、適切なタイミングでリトライ

- **入力値**:
  - fetch動作: 1回目は6秒後に応答（タイムアウト）、2回目は1秒後に200 OK
  - **不正な理由**: APIサーバーの処理が遅延している
  - **実際の発生シナリオ**: J-Quants APIサーバーの高負荷時

- **期待される結果**:
  - fetchが2回呼ばれる（1回目タイムアウト、2回目200）
  - 1回目のリクエストは5秒でAbortController.abort()が呼ばれる
  - 1秒待機後にリトライされる
  - **エラーメッセージの内容**: エラーがスローされない（リトライ成功）
  - **システムの安全性**: 無限待機を防ぎ、適切なタイムアウト制御

- **テストの目的**:
  - タイムアウト制御の動作確認
  - AbortControllerの使用確認
  - **品質保証の観点**: システムの応答性の保証

- **要件根拠**: REQ-603（タイムアウト制御）, REQ-601（リトライロジック）

- 🔵 **信頼性レベル**: 青信号（要件定義書とTokenManagerの実装パターンから確実）

---

### TC-ERROR-007: 最大リトライ回数超過（3回すべて失敗）🔵

- **テスト名**: 3回すべてのリクエストが失敗した場合はエラーをスローすること
  - **エラーケースの概要**: 継続的なサーバーエラーまたはネットワーク障害
  - **エラー処理の重要性**: 永続的なエラーに対して適切にユーザーに通知

- **入力値**:
  - APIレスポンス: 3回とも500エラー
  - **不正な理由**: サーバーが継続的に障害状態
  - **実際の発生シナリオ**: J-Quants APIサーバーのメンテナンス中、長期間の障害

- **期待される結果**:
  - fetchが3回呼ばれる（すべて500エラー）
  - 1秒待機、2秒待機の後にリトライされる
  - 最終的にErrorがスローされる
  - エラーメッセージが「APIリクエストに失敗しました（最大リトライ回数超過）」である
  - **エラーメッセージの内容**: ユーザーが問題を理解し、後で再試行できる内容
  - **システムの安全性**: 無限ループを避け、適切にエラーを通知

- **テストの目的**:
  - 最大リトライ回数の制限確認
  - 永続的エラーの処理確認
  - **品質保証の観点**: システムの安定性の保証

- **要件根拠**: REQ-601（リトライロジック）

- 🔵 **信頼性レベル**: 青信号（要件定義書の仕様に基づく）

---

## 3. 境界値テストケース（6件）

### TC-BOUNDARY-001: リトライロジック（1回目失敗、2回目成功）🔵

- **テスト名**: 1回目失敗、2回目成功のリトライパターン
  - **境界値の意味**: リトライの最小成功パターン
  - **境界値での動作保証**: 最小限のリトライで成功することを確認

- **入力値**:
  - APIレスポンス: 1回目は500、2回目は200 OK
  - **境界値選択の根拠**: リトライロジックの最も基本的なパターン
  - **実際の使用場面**: サーバーの一時的な障害が即座に回復する場合

- **期待される結果**:
  - fetchが2回呼ばれる
  - 1秒待機後にリトライされる
  - 最終的に正常なレスポンスが返却される
  - **境界での正確性**: リトライ間隔が正確に1秒であること
  - **一貫した動作**: リトライロジックが確実に動作すること

- **テストの目的**:
  - リトライの最小パターン確認
  - 待機時間の正確性確認
  - **堅牢性の確認**: 最小限のリトライで回復できることを保証

- **要件根拠**: REQ-601（リトライロジック）

- 🔵 **信頼性レベル**: 青信号（要件定義書の仕様に基づく）

---

### TC-BOUNDARY-002: リトライロジック（2回目失敗、3回目成功）🔵

- **テスト名**: 2回目失敗、3回目成功のリトライパターン
  - **境界値の意味**: リトライの最大成功パターン
  - **境界値での動作保証**: 最大リトライ回数ぎりぎりで成功することを確認

- **入力値**:
  - APIレスポンス: 1回目は500、2回目は500、3回目は200 OK
  - **境界値選択の根拠**: リトライの限界点での成功を確認
  - **実際の使用場面**: サーバーの回復に時間がかかる場合

- **期待される結果**:
  - fetchが3回呼ばれる
  - 1秒待機、2秒待機後にリトライされる
  - 最終的に正常なレスポンスが返却される
  - **境界での正確性**: リトライ間隔が正確に1秒→2秒であること
  - **一貫した動作**: 3回目でも確実に成功を処理できること

- **テストの目的**:
  - リトライの最大成功パターン確認
  - Exponential backoffの完全な動作確認
  - **堅牢性の確認**: 最大リトライ回数で成功できることを保証

- **要件根拠**: REQ-601（リトライロジック）

- 🔵 **信頼性レベル**: 青信号（要件定義書の仕様に基づく）

---

### TC-BOUNDARY-003: Exponential backoff（1秒→2秒の待機時間）🔵

- **テスト名**: リトライ間隔が正確に1秒→2秒で増加すること
  - **境界値の意味**: Exponential backoffの正確性
  - **境界値での動作保証**: 待機時間が仕様通りであることを確認

- **入力値**:
  - APIレスポンス: 3回とも500エラー（待機時間測定のため）
  - **境界値選択の根拠**: リトライ間隔の正確性を検証
  - **実際の使用場面**: サーバー負荷を考慮したリトライ間隔の確認

- **期待される結果**:
  - 1回目失敗 → 1秒待機 → 2回目失敗 → 2秒待機 → 3回目失敗
  - setTimeout/setIntervalのモックで待機時間を測定
  - 待機時間が正確に1000ms、2000msであること
  - **境界での正確性**: 時間測定の誤差が±50ms以内
  - **一貫した動作**: 常に同じ待機時間パターンを維持

- **テストの目的**:
  - Exponential backoffアルゴリズムの正確性確認
  - 時間計測の正確性確認
  - **堅牢性の確認**: タイマー処理が正確であることを保証

- **要件根拠**: REQ-601（リトライロジック、Exponential backoff）

- 🟡 **信頼性レベル**: 黄信号（時間測定のテスト実装方法は要検討）

---

### TC-BOUNDARY-004: タイムアウト境界値（ちょうど5秒）🔵

- **テスト名**: 5秒ちょうどでタイムアウトすること
  - **境界値の意味**: タイムアウト時間の正確性
  - **境界値での動作保証**: 指定時間ぴったりでタイムアウトすることを確認

- **入力値**:
  - fetch動作: 5.1秒後に応答（タイムアウト）
  - **境界値選択の根拠**: タイムアウト時間の境界を確認
  - **実際の使用場面**: APIサーバーの応答が遅延する場合

- **期待される結果**:
  - AbortController.abort()が5秒後に呼ばれる
  - fetchがキャンセルされる
  - タイムアウトエラーがスローされる
  - **境界での正確性**: タイムアウト時間の誤差が±100ms以内
  - **一貫した動作**: 常に5秒でタイムアウトすること

- **テストの目的**:
  - タイムアウト時間の正確性確認
  - AbortControllerの動作確認
  - **堅牢性の確認**: タイムアウト処理が確実に動作することを保証

- **要件根拠**: REQ-603（タイムアウト制御）

- 🔵 **信頼性レベル**: 青信号（TokenManagerの実装パターンから確実）

---

### TC-BOUNDARY-005: 空のレスポンスボディ🟡

- **テスト名**: APIが空のレスポンスボディを返した場合の処理
  - **境界値の意味**: レスポンスボディの最小ケース
  - **境界値での動作保証**: 空配列や空オブジェクトを正しく処理できることを確認

- **入力値**:
  - APIレスポンス: 200 OK、ボディは`[]`（空配列）
  - **境界値選択の根拠**: データが存在しない場合の動作を確認
  - **実際の使用場面**: 検索結果が0件の場合

- **期待される結果**:
  - エラーがスローされない
  - 返却値が空配列`[]`である
  - **境界での正確性**: 空配列が正しくマッピングされること
  - **一貫した動作**: 空データでもエラーにならないこと

- **テストの目的**:
  - 空データの処理確認
  - エッジケースでのエラーハンドリング確認
  - **堅牢性の確認**: 予期しないデータでもクラッシュしないことを保証

- **要件根拠**: EDGE-003（空データ）

- 🟡 **信頼性レベル**: 黄信号（要件定義書に明記されていないため、推測）

---

### TC-BOUNDARY-006: 大量データ取得（1000件以上）🟡

- **テスト名**: 1000件以上のデータを取得できること
  - **境界値の意味**: データ量の最大ケース
  - **境界値での動作保証**: 大量データでもメモリエラーやパフォーマンス問題が発生しないことを確認

- **入力値**:
  - APIレスポンス: 200 OK、ボディは1000件のCompany配列
  - **境界値選択の根拠**: 実運用での最大データ量を想定
  - **実際の使用場面**: 全銘柄一覧取得（約4000銘柄）

- **期待される結果**:
  - エラーがスローされない
  - 返却値が1000件のCompany配列である
  - テスト実行時間が3秒以内（パフォーマンス確認）
  - **境界での正確性**: すべてのデータが正しくマッピングされること
  - **一貫した動作**: 大量データでもメモリリークが発生しないこと

- **テストの目的**:
  - 大量データの処理確認
  - パフォーマンスの確認
  - **堅牢性の確認**: スケーラビリティの保証

- **要件根拠**: NFR-001（パフォーマンス要件）

- 🟡 **信頼性レベル**: 黄信号（要件定義書に具体的な件数の記載なし、推測）

---

## 4. テストケース実装時の日本語コメント指針

### 🔵 テストケース開始時のコメント例

```typescript
/**
 * TC-NORMAL-001: 基本HTTPリクエスト（GET /listed/info）🔵
 *
 * 【テスト目的】: JQuantsClient.getListedInfo()が正常にHTTPリクエストを送信し、
 *                 Company[]型のレスポンスを取得できることを確認
 * 【テスト内容】: fetchをモックし、GET /listed/infoを呼び出し、
 *                 レスポンスが正しくマッピングされることを検証
 * 【期待される動作】: Company[]型の配列が返却され、各要素が正しい構造を持つ
 * 【要件根拠】: REQ-001（認証）, REQ-002（IDトークン取得）
 * 🔵 信頼性レベル: 青信号（要件定義書、既存実装パターンに基づく）
 */
it('TC-NORMAL-001: 基本HTTPリクエスト（GET /listed/info）', async () => {
  // テスト実装...
});
```

### 🔵 Given-When-Thenパターンのコメント例

```typescript
// ===== Given（前提条件）=====
// 【テストデータ準備】: TokenManagerをモックし、有効なIDトークンを返却するように設定
// 【初期条件設定】: J-Quants APIが正常なレスポンスを返すようにfetchをモック
// 【前提条件確認】: キャッシュファイルが存在しない状態を確保

// ===== When（実行条件）=====
// 【実際の処理実行】: JQuantsClient.getListedInfo()を呼び出し、銘柄一覧を取得
// 【処理内容】: TokenManagerからIDトークンを取得し、認証ヘッダー付きでAPIリクエストを送信
// 【実行タイミング】: TokenManagerの初期化直後、キャッシュが存在しない状態で実行

// ===== Then（期待結果）=====
// 【結果検証】: 返却値がCompany[]型であることを確認
// 【期待値確認】: 配列の各要素がCompanyインターフェースを満たすことを確認
// 【品質保証】: この検証により、HTTP通信とレスポンスマッピングの正確性を保証
```

### 🔵 各expectステートメントのコメント例

```typescript
// 【検証項目】: IDトークンが正しく取得されることを確認
// 🔵 信頼性レベル: 青信号（TokenManagerの実装から確実）
expect(idToken).toBe('test_token_12345');

// 【検証項目】: fetchが正確に1回呼ばれることを確認（重複リクエスト防止）
// 🔵 信頼性レベル: 青信号（モックの動作から確実）
expect(mockFetch).toHaveBeenCalledTimes(1);

// 【検証項目】: Authorization ヘッダーが正しい形式で付与されることを確認
// 🔵 信頼性レベル: 青信号（NFR-101セキュリティ要件に基づく）
expect(mockFetch).toHaveBeenCalledWith(
  expect.any(String),
  expect.objectContaining({
    headers: expect.objectContaining({
      'Authorization': 'Bearer test_token_12345'
    })
  })
);
```

---

## 5. テストケース実装順序

### Red Phase実装順序（推奨）

1. **正常系テストケース（9件）**: 基本動作を最初に確認
2. **異常系テストケース（7件）**: エラーハンドリングを次に確認
3. **境界値テストケース（6件）**: 特殊ケースを最後に確認

### テストファイル構成

```typescript
// tests/api/j-quants-client.test.ts
describe('JQuantsClient - 正常系テストケース', () => {
  // TC-NORMAL-001 ～ TC-NORMAL-009
});

describe('JQuantsClient - 異常系テストケース', () => {
  // TC-ERROR-001 ～ TC-ERROR-007
});

describe('JQuantsClient - 境界値テストケース', () => {
  // TC-BOUNDARY-001 ～ TC-BOUNDARY-006
});
```

---

## 6. モック戦略

### 🔵 TokenManager モック

```typescript
const mockTokenManager = {
  getIdToken: vi.fn().mockResolvedValue('test_token_12345'),
};
```

### 🔵 fetch API モック

```typescript
const mockFetch = vi.fn(() =>
  Promise.resolve({
    ok: true,
    status: 200,
    json: async () => ({ /* レスポンスデータ */ }),
  } as Response)
);
global.fetch = mockFetch as any;
```

### 🔵 AbortController モック

```typescript
const mockAbortController = {
  abort: vi.fn(),
  signal: {} as AbortSignal,
};
vi.spyOn(globalThis, 'AbortController').mockImplementation(() => mockAbortController as any);
```

---

## 7. 完了基準

- [ ] 22件のテストケースがすべて実装されている
- [ ] すべてのテストが失敗する（Red Phase）
- [ ] 各テストに日本語コメントが詳細に記載されている
- [ ] Given-When-Thenパターンが一貫して使用されている
- [ ] モック戦略が明確に定義されている
- [ ] テストケース仕様書が作成されている（このファイル）

---

## 8. 品質判定

### ✅ 高品質: 基準をすべて満たす

- **テストケース分類**: ✅ 正常系9件 + 異常系7件 + 境界値6件 = 22件（十分な網羅性）
- **期待値定義**: ✅ 各テストケースの入力値、期待される結果、テスト目的が明確
- **技術選択**: ✅ TypeScript 5.6.3 + Vitest 2.1.4（既存プロジェクトと一致）
- **実装可能性**: ✅ 既存のTokenManagerテストパターンを参考に実装可能

### 📊 要件網羅率

| 要件ID | 対応テストケース | 網羅率 |
|--------|-----------------|-------|
| REQ-001 | TC-NORMAL-001, 002 | 100% |
| REQ-002 | TC-NORMAL-001, 002, 006, 007, 008, 009 | 100% |
| REQ-004 | TC-ERROR-002 | 100% |
| REQ-601 | TC-ERROR-001 ~ 007, TC-BOUNDARY-001 ~ 003 | 100% |
| REQ-602 | 全テストケース（ログ記録） | 100% |
| REQ-603 | TC-ERROR-006, TC-BOUNDARY-004 | 100% |
| NFR-001 | TC-BOUNDARY-006 | 100% |
| NFR-101 | TC-NORMAL-002 | 100% |
| NFR-301 | TC-ERROR-001 | 100% |

**総合要件網羅率**: 100% ✅

---

## 9. 次のステップ

### 🚀 次のお勧めステップ

```bash
/tsumiki:tdd-red
```

**実行内容**: このテストケース仕様書に基づいて、Vitestテストコードを実装します。
- `tests/api/j-quants-client.test.ts` を新規作成
- 22件のテストケースをすべて実装
- 実装が存在しないため、すべてのテストが失敗することを確認（Red Phase）

---

**作成者**: Claude (Sonnet 4.5)
**レビュー**: 未実施
**承認**: 未承認
**次のステップ**: `/tsumiki:tdd-red` でRed Phase（失敗するテスト作成）を開始します。
